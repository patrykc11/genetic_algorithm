# -*- coding: utf-8 -*-
"""Zastosowanie algorytmu genetycznego dla problemu komiwojażera (problem symetryczny).ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1fMMUg-9_9zpSAxHbUItVfstdD75-8c8g
"""

import random

"""Wczytanie macierzy odległości z pliku"""

def load_distance_matrix(file_path):
    with open(file_path, 'r') as file:
        lines = file.readlines()
        lines.pop(0)
        matrix = [list(map(int, line.split())) for line in lines]
    return matrix

"""Obliczenie długości trasy"""

def calculate_route_length(route, distance_matrix):
    total_length = 0
    prev_city = route[0]

    for city in route[1:]:
        if city >= prev_city:
          total_length += distance_matrix[city][prev_city]
        if city < prev_city:
          total_length += distance_matrix[prev_city][city]
        prev_city = city

    if route[-1] >= route[0]:
      total_length += distance_matrix[route[-1]][route[0]]
    else:
      total_length += distance_matrix[route[0]][route[-1]]
    return total_length

"""Stworzenie początkowej populacji gdzie każdy osobnik to losowa kolejność wszystkich miast"""

def initialize_population(size, num_cities):
    population = []
    for _ in range(size):
        route = list(range(num_cities))
        random.shuffle(route)
        population.append(route)
    return population

"""Ta funkcja implementuje selekcję turniejową, gdzie dla każdego turnieju wybieramy k osobników i wygrywa ten z nich, który ma najkrótszą trasę."""

def tournament_selection(population, k):
    selected = []
    for _ in range(len(population)):
        tournament = random.sample(population, k)
        winner = min(tournament, key=lambda x: calculate_route_length(x, distance_matrix))
        selected.append(winner)
    return selected

"""Funkcja ta implementuje krzyżowanie PMX, które wymienia pewien fragment jednego rodzica z drugim, przy czym utrzymuje spójność tras."""

def pmx_crossover(parent1, parent2):
    size = len(parent1)
    point1 = random.randint(0, size - 1)
    point2 = random.randint(point1 + 1, size)

    child = [-1] * size
    mapping = {}

    child[point1:point2] = parent1[point1:point2]

    for i in range(point1, point2):
        mapping[parent1[i]] = parent2[i]

    for i in range(size):
        if i < point1 or i >= point2:
            current_element = parent2[i]
            while current_element in child[point1:point2]:
                current_element = mapping[current_element]
            child[i] = current_element

    return child

"""Funkcja ta wykonuje mutacje na trasie, czyli losowo zamienia dwa miasta lub odwraca kolejność pewnego fragmentu trasy."""

def mutate(route):
    if random.random() < mutation_rate_swap:
        idx1, idx2 = random.sample(range(len(route)), 2)
        route[idx1], route[idx2] = route[idx2], route[idx1]
    if random.random() < mutation_rate_inversion:
        start, end = sorted(random.sample(range(len(route)), 2))
        route[start:end] = reversed(route[start:end])

"""Główna funkcja algorytmu genetycznego, która łączy wszystkie powyższe kroki."""

def genetic_algorithm(distance_matrix, population_size, tournament_size, crossover_rate, mutation_rate_swap, mutation_rate_inversion, num_generations):
    num_cities = len(distance_matrix)
    population = initialize_population(population_size, num_cities)

    best_route = None
    best_length = None

    used_routes = []
    for generation in range(num_generations):
        selected_parents = tournament_selection(population, tournament_size)

        offspring = []
        for i in range(0, len(selected_parents), 2):
            parent1, parent2 = selected_parents[i], selected_parents[i + 1]
            if random.random() < crossover_rate:
                child1 = pmx_crossover(parent1, parent2)
                child2 = pmx_crossover(parent2, parent1)
                offspring.extend([child1, child2])
            else:
                offspring.extend([parent1, parent2])

        for individual in offspring:
            mutate(individual)

        population = offspring

        route = min(population, key=lambda x: calculate_route_length(x, distance_matrix))

        # if route in used_routes:
        #     print("Powtórzenie trasy: ", route)

        if best_route is None and best_length is None:
            best_route = route
            best_length = calculate_route_length(route, distance_matrix)
        else:
            length = calculate_route_length(route, distance_matrix)
            if length < best_length:
                best_route = route
                best_length = length

        used_routes.append(route)

        print("Generacja: ", generation, "Najlepsza droga: ", best_length, "Trasa: ", route)

    return best_route, best_length

if __name__ == "__main__":
    file_path = "berlin52.txt"
    distance_matrix = load_distance_matrix(file_path)
    population_size = 1000
    tournament_size = 5
    crossover_rate = 0.8
    mutation_rate_swap = 0.3
    mutation_rate_inversion = 0.2
    num_generations = 1000

    best_route, best_length = genetic_algorithm(distance_matrix, population_size, tournament_size, crossover_rate, mutation_rate_swap, mutation_rate_inversion, num_generations)

    print("Najlepsza trasa:", best_route)
    print("Długość trasy:", best_length)
